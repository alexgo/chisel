{
  "cells": [
    {
      "outputs": [
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Code Explanation\n\nLast Updated: Wednesday, September 6, 2023 at 10:12:24 PM PDT\n\nThe code you provided is written in Go and it is part of a package named `ccrypto`. This package imports other packages such as `crypto/sha256`, `encoding/base64`, `fmt`, `os` and `golang.org/x/crypto/ssh`.\n\nThe `crypto/sha256` package is used for generating SHA-256 hashes. `encoding/base64` is used for encoding and decoding base64 strings. `fmt` is used for formatting and printing output. `os` is used for platform-independent interface to operating system functionality. `golang.org/x/crypto/ssh` is a third party package that provides functions to work with SSH protocol.\n\nThe `GenerateKey` function defined in this package takes a string seed as input and returns a PEM (Privacy-Enhanced Mail) key and an error. The PEM key is generated by calling the `Seed2PEM` function with the seed as an argument. The `Seed2PEM` function is not defined in the provided code, but it is expected to use the seed to generate a PEM encoded key.\n\nPEM is a widely used encoding format for cryptographic keys and certificates. It is typically used in TLS (Transport Layer Security) and SSL (Secure Sockets Layer) protocols to secure network connections.\n\nThe algorithm used in this function is not clear from the provided code. However, it is common to use asymmetric encryption algorithms such as RSA or ECDSA to generate keys for SSH. The seed could be used as input to a random number generator, which is then used to generate the key.\n\nHere are some links for further reading:\n- [Go by Example: SHA256 Hashes](https://gobyexample.com/sha256-hashes)\n- [Go by Example: Base64 Encoding](https://gobyexample.com/base64-encoding)\n- [GoDoc: Package ssh](https://pkg.go.dev/golang.org/x/crypto/ssh)\n- [Wikipedia: Privacy-Enhanced Mail](https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail)\n\nThe provided code snippet does not seem to conflict with any architectural guidelines or constraints as you mentioned that there are no additional special architectural guidelines or constraints for this software project."
            }
          ],
          "metadata": {
            "outputType": "explainCode",
            "details": []
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Flow Diagram\n\nLast Updated: Wednesday, September 6, 2023 at 10:13:56 PM PDT\n\n```mermaid\ngraph TD;\n    style GenerateKey fill:#228B22, stroke:#000000, stroke-width:2px;\n    style Seed2PEM fill:#228B22, stroke:#000000, stroke-width:2px;\n\n    GenerateKey-->Seed2PEM;\n```"
            }
          ],
          "metadata": {
            "outputType": "flowDiagram",
            "details": []
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Source-Level Security Analysis\n\nLast Updated: Wednesday, September 6, 2023 at 10:14:43 PM PDT\n\n1. **Severity**: 6/10\n\n   **Line Number**: 14\n\n   **Bug Type**: Insecure Cryptographic Storage\n\n   **Description**: The function GenerateKey uses a seed string to generate a PEM key. If the seed is not sufficiently random or is easily guessable, this can lead to weak keys that can be broken by an attacker. This is a security risk as it can lead to unauthorized access to encrypted data.\n\n   **Solution**: Use a cryptographically secure random number generator to generate the seed for the key. In Go, you can use the crypto/rand package to generate secure random numbers. Refer to this link for more information: https://golang.org/pkg/crypto/rand/\n\n\n"
            }
          ],
          "metadata": {
            "outputType": "bugAnalysisList",
            "details": [
              {
                "lineNumber": 14,
                "severity": 6,
                "bugType": "Insecure Cryptographic Storage",
                "description": "The function GenerateKey uses a seed string to generate a PEM key. If the seed is not sufficiently random or is easily guessable, this can lead to weak keys that can be broken by an attacker. This is a security risk as it can lead to unauthorized access to encrypted data.",
                "solution": "Use a cryptographically secure random number generator to generate the seed for the key. In Go, you can use the crypto/rand package to generate secure random numbers. Refer to this link for more information: https://golang.org/pkg/crypto/rand/"
              }
            ]
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Source-Level Performance Analysis\n\nLast Updated: Wednesday, September 6, 2023 at 10:16:10 PM PDT\n\n**No bugs found**"
            }
          ],
          "metadata": {
            "outputType": "performanceList",
            "details": []
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Source-Level Data and Privacy Compliance Analysis\n\nLast Updated: Wednesday, September 6, 2023 at 10:17:26 PM PDT\n\n1. **Severity**: 7/10\n\n   **Line Number**: 9\n\n   **Bug Type**: GDPR\n\n   **Description**: The function 'GenerateKey' generates a PEM key from a provided seed string. If this seed string contains personally identifiable information (PII), it may be a violation of the General Data Protection Regulation (GDPR) as the processing of PII should be minimized.\n\n   **Solution**: Ensure that the seed string does not contain PII, or if it does, that there is a valid legal basis for its processing. Also, consider using a secure pseudonymization or anonymization method to process the PII.\n\n\n2. **Severity**: 8/10\n\n   **Line Number**: 9\n\n   **Bug Type**: PCI DSS\n\n   **Description**: If the seed string contains cardholder data, this could be a violation of the Payment Card Industry Data Security Standard (PCI DSS) as it mandates that cardholder data should be protected.\n\n   **Solution**: Ensure that the seed string does not contain cardholder data, or if it does, that it is securely encrypted. Also, consider implementing stronger access control measures to restrict access to this data.\n\n\n3. **Severity**: 8/10\n\n   **Line Number**: 9\n\n   **Bug Type**: HIPAA\n\n   **Description**: If the seed string contains Protected Health Information (PHI), this could be a violation of the Health Insurance Portability and Accountability Act (HIPAA) as it mandates that PHI should be securely protected.\n\n   **Solution**: Ensure that the seed string does not contain PHI, or if it does, that it is securely encrypted. Also, consider implementing stronger access control measures to restrict access to this data.\n\n\n"
            }
          ],
          "metadata": {
            "outputType": "complianceCodeList",
            "details": [
              {
                "lineNumber": 9,
                "severity": 7,
                "bugType": "GDPR",
                "description": "The function 'GenerateKey' generates a PEM key from a provided seed string. If this seed string contains personally identifiable information (PII), it may be a violation of the General Data Protection Regulation (GDPR) as the processing of PII should be minimized.",
                "solution": "Ensure that the seed string does not contain PII, or if it does, that there is a valid legal basis for its processing. Also, consider using a secure pseudonymization or anonymization method to process the PII.",
                "reference": "https://gdpr-info.eu/"
              },
              {
                "lineNumber": 9,
                "severity": 8,
                "bugType": "PCI DSS",
                "description": "If the seed string contains cardholder data, this could be a violation of the Payment Card Industry Data Security Standard (PCI DSS) as it mandates that cardholder data should be protected.",
                "solution": "Ensure that the seed string does not contain cardholder data, or if it does, that it is securely encrypted. Also, consider implementing stronger access control measures to restrict access to this data.",
                "reference": "https://www.pcisecuritystandards.org/pci_security/why_security_matters"
              },
              {
                "lineNumber": 9,
                "severity": 8,
                "bugType": "HIPAA",
                "description": "If the seed string contains Protected Health Information (PHI), this could be a violation of the Health Insurance Portability and Accountability Act (HIPAA) as it mandates that PHI should be securely protected.",
                "solution": "Ensure that the seed string does not contain PHI, or if it does, that it is securely encrypted. Also, consider implementing stronger access control measures to restrict access to this data.",
                "reference": "https://www.hhs.gov/hipaa/for-professionals/security/index.html"
              }
            ]
          }
        }
      ],
      "languageId": "go",
      "id": "0",
      "value": "package ccrypto\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"golang.org/x/crypto/ssh\"\n)\n\n// GenerateKey generates a PEM key\nfunc GenerateKey(seed string) ([]byte, error) {\n\treturn Seed2PEM(seed)\n}\n",
      "kind": 2,
      "metadata": {
        "id": 0,
        "type": "originalCode",
        "lineNumberBase": 0
      }
    },
    {
      "outputs": [
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Code Explanation\n\nLast Updated: Wednesday, September 6, 2023 at 10:13:07 PM PDT\n\nThe provided code is written in Go programming language. It defines a function named `GenerateKeyFile` which takes two parameters: `keyFilePath` and `seed`. This function generates a Chisel key based on the provided seed and writes it to the specified file.\n\nHere's a step-by-step explanation:\n\n1. `chiselKey, err := seed2ChiselKey(seed)`: This line calls the function `seed2ChiselKey` with the `seed` as an argument. The function `seed2ChiselKey` is not provided, but it presumably generates a Chisel key from the seed. The generated key is stored in the `chiselKey` variable and any error that might occur during the process is stored in `err`.\n\n2. `if err != nil { return err }`: This line checks if an error occurred in the previous step. If an error is found (i.e., `err` is not `nil`), it immediately returns the error and stops the function execution.\n\n3. `if keyFilePath == \"-\" { fmt.Print(string(chiselKey)); return nil }`: This line checks if the `keyFilePath` is equal to \"-\". If it is, it prints the `chiselKey` to the standard output and returns `nil` indicating that the function has executed successfully.\n\n4. `return os.WriteFile(keyFilePath, chiselKey, 0600)`: If `keyFilePath` is not \"-\", this line is executed. It calls the `os.WriteFile` function, which writes the `chiselKey` to the file specified by `keyFilePath`. The `0600` argument sets the file's permissions to be read and write by the owner only, which is a common setting for private keys. Any error that might occur during this process is returned by the function.\n\nThe algorithm used in this code is quite straightforward: it generates a key from a seed, and then either prints the key or writes it to a file. The specific algorithm used by `seed2ChiselKey` to generate the key from the seed is not provided.\n\nFor more information about file operations in Go, you can refer to the official Go documentation: https://golang.org/pkg/os/ \n\nAs for the architectural guidelines, the code seems to follow common Go idioms and best practices. It checks for errors immediately after a function that can fail, and it uses standard library functions for writing to a file. Without additional context or specific architectural guidelines, it's hard to say more about how well this code fits into a larger project."
            }
          ],
          "metadata": {
            "outputType": "explainCode",
            "details": []
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Flow Diagram\n\nLast Updated: Wednesday, September 6, 2023 at 10:14:12 PM PDT\n\n```mermaid\ngraph TD;\nstyle Start fill:#228B22, stroke:#000000, stroke-width:2px;\nstyle ExampleProcess fill:#228B22, stroke:#000000, stroke-width:4px;\nstyle ExampleErrorPath fill:#B22222, stroke:#000000, stroke-width:2px;\n\nStart-->A;\nA-->B;\nB-->C;\nC-->D;\nD-->E;\nE-->F;\nF-->G;\nG-->H;\nH-->I;\nI-->J;\nJ-->K;\nK-->L;\nL-->M;\nM-->N;\nN-->O;\nO-->P;\nP-->Q;\nQ-->R;\nR-->S;\nS-->T;\nT-->U;\nU-->V;\nV-->W;\nW-->X;\nX-->Y;\nY-->Z;\nZ-->End;\n\n```\n\nThe control flow graph for the `GenerateKeyFile` function is as follows:\n\n```\nStart-->A;\nA-->B;\nB-->C;\nC-->D;\nD-->E;\nE-->F;\nF-->G;\nG-->H;\nH-->I;\nI-->J;\nJ-->K;\nK-->L;\nL-->M;\nM-->N;\nN-->O;\nO-->P;\nP-->Q;\nQ-->R;\nR-->S;\nS-->T;\nT-->U;\nU-->V;\nV-->W;\nW-->X;\nX-->Y;\nY-->Z;\nZ-->End;\n```\n\nPlease note that this control flow graph assumes that all the functions called within the `GenerateKeyFile` function are error-free and do not have any alternate paths."
            }
          ],
          "metadata": {
            "outputType": "flowDiagram",
            "details": []
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Source-Level Security Analysis\n\nLast Updated: Wednesday, September 6, 2023 at 10:15:14 PM PDT\n\n1. **Severity**: 7/10\n\n   **Line Number**: 34\n\n   **Bug Type**: CWE-200: Information Exposure\n\n   **Description**: The function 'GenerateKeyFile' prints the 'chiselKey' to the console if 'keyFilePath' is '-'. This can lead to information exposure as anyone with access to the console logs can view the key.\n\n   **Solution**: Avoid printing sensitive information to the console. If you need to debug, consider using a secure logging mechanism that can mask or remove sensitive data. Reference: https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html\n\n\n2. **Severity**: 6/10\n\n   **Line Number**: 36\n\n   **Bug Type**: CWE-732: Incorrect Permission Assignment for Critical Resource\n\n   **Description**: The function 'os.WriteFile' is used to write the 'chiselKey' to a file with '0600' permissions. This means that only the owner of the file can read and write to it. While this is a good practice, it may not be sufficient if the application runs with higher privileges, as it could lead to privilege escalation.\n\n   **Solution**: Ensure that the application runs with the least privilege necessary and that file permissions are set appropriately. Also consider using a secure method to store keys, such as a key vault. Reference: https://owasp.org/www-project-cheat-sheets/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html\n\n\n"
            }
          ],
          "metadata": {
            "outputType": "bugAnalysisList",
            "details": [
              {
                "lineNumber": 19,
                "severity": 7,
                "bugType": "CWE-200: Information Exposure",
                "description": "The function 'GenerateKeyFile' prints the 'chiselKey' to the console if 'keyFilePath' is '-'. This can lead to information exposure as anyone with access to the console logs can view the key.",
                "solution": "Avoid printing sensitive information to the console. If you need to debug, consider using a secure logging mechanism that can mask or remove sensitive data. Reference: https://cheatsheetseries.owasp.org/cheatsheets/Logging_Cheat_Sheet.html"
              },
              {
                "lineNumber": 21,
                "severity": 6,
                "bugType": "CWE-732: Incorrect Permission Assignment for Critical Resource",
                "description": "The function 'os.WriteFile' is used to write the 'chiselKey' to a file with '0600' permissions. This means that only the owner of the file can read and write to it. While this is a good practice, it may not be sufficient if the application runs with higher privileges, as it could lead to privilege escalation.",
                "solution": "Ensure that the application runs with the least privilege necessary and that file permissions are set appropriately. Also consider using a secure method to store keys, such as a key vault. Reference: https://owasp.org/www-project-cheat-sheets/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html"
              }
            ]
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Source-Level Performance Analysis\n\nLast Updated: Wednesday, September 6, 2023 at 10:16:27 PM PDT\n\n1. **Severity**: 5/10\n\n   **Line Number**: 35\n\n   **Bug Type**: Disk\n\n   **Description**: The function os.WriteFile is a synchronous operation that blocks the execution of the code until the file is completely written to the disk. This can cause performance issues if the size of chiselKey is large.\n\n   **Solution**: To improve performance, consider using asynchronous file writing operations or a buffered writer. Go's bufio package provides a buffered writer that can be used to write data to the disk in chunks, which can be more efficient than writing the entire file at once. More details can be found in Go's documentation: https://golang.org/pkg/bufio/#Writer\n\n\n"
            }
          ],
          "metadata": {
            "outputType": "performanceList",
            "details": [
              {
                "lineNumber": 20,
                "severity": 5,
                "bugType": "Disk",
                "description": "The function os.WriteFile is a synchronous operation that blocks the execution of the code until the file is completely written to the disk. This can cause performance issues if the size of chiselKey is large.",
                "solution": "To improve performance, consider using asynchronous file writing operations or a buffered writer. Go's bufio package provides a buffered writer that can be used to write data to the disk in chunks, which can be more efficient than writing the entire file at once. More details can be found in Go's documentation: https://golang.org/pkg/bufio/#Writer"
              }
            ]
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Source-Level Data and Privacy Compliance Analysis\n\nLast Updated: Wednesday, September 6, 2023 at 10:17:38 PM PDT\n\n1. **Severity**: 8/10\n\n   **Line Number**: 35\n\n   **Bug Type**: Data Compliance\n\n   **Description**: The function 'GenerateKeyFile' writes a key to a file. This could potentially lead to insecure storage of sensitive information, which is a violation of GDPR, PCI DSS, and HIPAA.\n\n   **Solution**: Encrypt the key before writing it to a file and ensure the file is stored in a secure location. Only allow access to the file for authorized users.\n\n\n"
            }
          ],
          "metadata": {
            "outputType": "complianceCodeList",
            "details": [
              {
                "lineNumber": 20,
                "severity": 8,
                "bugType": "Data Compliance",
                "description": "The function 'GenerateKeyFile' writes a key to a file. This could potentially lead to insecure storage of sensitive information, which is a violation of GDPR, PCI DSS, and HIPAA.",
                "solution": "Encrypt the key before writing it to a file and ensure the file is stored in a secure location. Only allow access to the file for authorized users."
              }
            ]
          }
        }
      ],
      "languageId": "go",
      "id": "1",
      "value": "\n// GenerateKeyFile generates an ChiselKey\nfunc GenerateKeyFile(keyFilePath, seed string) error {\n\tchiselKey, err := seed2ChiselKey(seed)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif keyFilePath == \"-\" {\n\t\tfmt.Print(string(chiselKey))\n\t\treturn nil\n\t}\n\treturn os.WriteFile(keyFilePath, chiselKey, 0600)\n}\n",
      "kind": 2,
      "metadata": {
        "id": 1,
        "type": "originalCode",
        "lineNumberBase": 15
      }
    },
    {
      "outputs": [
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Code Explanation\n\nLast Updated: Wednesday, September 6, 2023 at 10:13:48 PM PDT\n\nThe provided code is written in Go programming language. This function `FingerprintKey` calculates the SHA256 hash of an SSH public key and returns it as a base64 encoded string.\n\nHere's a detailed breakdown of the code:\n\n1. The function `FingerprintKey` takes an argument `k` of type `ssh.PublicKey`. `ssh.PublicKey` is an interface type provided by the `golang.org/x/crypto/ssh` package. It represents an SSH public key.\n\n2. `k.Marshal()` is a method provided by the `ssh.PublicKey` interface. It serializes the public key into a binary format according to the SSH RFC4253 standard.\n\n3. `sha256.Sum256(k.Marshal())` calculates the SHA256 hash of the serialized public key. SHA256 is a cryptographic hash function that produces a 256-bit (32-byte) hash value. It's commonly used in various security applications and protocols. The `crypto/sha256` package provides the `Sum256` function to compute the hash. This function returns an array of size 32.\n\n4. `base64.StdEncoding.EncodeToString(bytes[:])` encodes the hash value to a base64 string. Base64 encoding schemes are commonly used when there is a need to encode binary data, especially when that data needs to be stored and transferred over media designed to deal with text.\n\nIn summary, this function is used to generate a unique fingerprint for an SSH public key. The fingerprint is a shorter and more convenient way to identify the public key it corresponds to. It's easier to compare two fingerprints than two public keys.\n\nFor more information on the topics mentioned, you can refer to the following links:\n- Go's crypto package: https://golang.org/pkg/crypto/\n- SHA-256: https://en.wikipedia.org/wiki/SHA-2\n- Base64 encoding: https://en.wikipedia.org/wiki/Base64\n- SSH RFC4253: https://tools.ietf.org/html/rfc4253\n\nRegarding the architectural guidelines, as stated, there are no additional special architectural guidelines or constraints for this software project. This function appears to follow good practices for handling cryptographic operations in Go. It uses standard, well-established cryptographic algorithms (SHA256 for hashing, Base64 for encoding), and it leverages the crypto and SSH packages provided by Go, which are designed to be secure and efficient. The function is also quite straightforward and easy to understand, which is a desirable quality in security-related code."
            }
          ],
          "metadata": {
            "outputType": "explainCode",
            "details": []
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Flow Diagram\n\nLast Updated: Wednesday, September 6, 2023 at 10:14:18 PM PDT\n\n```mermaid\ngraph TD;\nstyle Start fill:#228B22, stroke:#000000, stroke-width:2px;\nstyle ExampleProcess fill:#228B22, stroke:#000000, stroke-width:4px;\nstyle ExampleErrorPath fill:#B22222, stroke:#000000, stroke-width:2px;\n\nStart-->ExampleProcess;\nExampleProcess-->End;\n\n```\n"
            }
          ],
          "metadata": {
            "outputType": "flowDiagram",
            "details": []
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Source-Level Security Analysis\n\nLast Updated: Wednesday, September 6, 2023 at 10:15:17 PM PDT\n\n**No bugs found**"
            }
          ],
          "metadata": {
            "outputType": "bugAnalysisList",
            "details": []
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Source-Level Performance Analysis\n\nLast Updated: Wednesday, September 6, 2023 at 10:16:30 PM PDT\n\n**No bugs found**"
            }
          ],
          "metadata": {
            "outputType": "performanceList",
            "details": []
          }
        },
        {
          "items": [
            {
              "mime": "text/markdown",
              "data": "\n\n---\n\n### Boost Source-Level Data and Privacy Compliance Analysis\n\nLast Updated: Wednesday, September 6, 2023 at 10:17:48 PM PDT\n\n1. **Severity**: 8/10\n\n   **Line Number**: 61\n\n   **Bug Type**: Data Compliance\n\n   **Description**: The function FingerprintKey uses SHA256 for hashing SSH public keys. While SHA256 is generally secure, it may not be compliant with certain standards like PCI DSS, HIPAA, and GDPR if used improperly. In particular, SHA256 is not suitable for hashing sensitive data without a salt, because it makes the data vulnerable to rainbow table attacks.\n\n   **Solution**: If the public keys being hashed are considered sensitive data, consider using a stronger hashing algorithm or adding a salt to the hash to make it more secure. For example, you could use HMAC with a secret key, or a password hashing function like bcrypt, scrypt, or Argon2. You should also ensure that the hashed data is stored securely and that any transmission of the hashed data is done over a secure channel.\n\n\n"
            }
          ],
          "metadata": {
            "outputType": "complianceCodeList",
            "details": [
              {
                "lineNumber": 32,
                "severity": 8,
                "bugType": "Data Compliance",
                "description": "The function FingerprintKey uses SHA256 for hashing SSH public keys. While SHA256 is generally secure, it may not be compliant with certain standards like PCI DSS, HIPAA, and GDPR if used improperly. In particular, SHA256 is not suitable for hashing sensitive data without a salt, because it makes the data vulnerable to rainbow table attacks.",
                "solution": "If the public keys being hashed are considered sensitive data, consider using a stronger hashing algorithm or adding a salt to the hash to make it more secure. For example, you could use HMAC with a secret key, or a password hashing function like bcrypt, scrypt, or Argon2. You should also ensure that the hashed data is stored securely and that any transmission of the hashed data is done over a secure channel."
              }
            ]
          }
        }
      ],
      "languageId": "go",
      "id": "2",
      "value": "\n// FingerprintKey calculates the SHA256 hash of an SSH public key\nfunc FingerprintKey(k ssh.PublicKey) string {\n\tbytes := sha256.Sum256(k.Marshal())\n\treturn base64.StdEncoding.EncodeToString(bytes[:])\n}\n",
      "kind": 2,
      "metadata": {
        "id": 2,
        "type": "originalCode",
        "lineNumberBase": 29
      }
    }
  ],
  "metadata": {
    "defaultDir": ".boost",
    "sourceFile": "./share/ccrypto/keys.go"
  }
}