{
  "cells": [
    {
      "outputs": [],
      "languageId": "go",
      "id": "0",
      "value": "package chclient\n\nimport (\n\t\"context\"\n\t\"crypto/md5\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\tchshare \"github.com/jpillora/chisel/share\"\n\t\"github.com/jpillora/chisel/share/ccrypto\"\n\t\"github.com/jpillora/chisel/share/cio\"\n\t\"github.com/jpillora/chisel/share/cnet\"\n\t\"github.com/jpillora/chisel/share/settings\"\n\t\"github.com/jpillora/chisel/share/tunnel\"\n\n\t\"golang.org/x/crypto/ssh\"\n\t\"golang.org/x/net/proxy\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\n// Config represents a client configuration\ntype Config struct {\n\tFingerprint      string\n\tAuth             string\n\tKeepAlive        time.Duration\n\tMaxRetryCount    int\n\tMaxRetryInterval time.Duration\n\tServer           string\n\tProxy            string\n\tRemotes          []string\n\tHeaders          http.Header\n\tTLS              TLSConfig\n\tDialContext      func(ctx context.Context, network, addr string) (net.Conn, error)\n\tVerbose          bool\n}\n",
      "kind": 2,
      "metadata": {
        "id": 0,
        "type": "originalCode",
        "lineNumberBase": 0
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "1",
      "value": "\n// TLSConfig for a Client\ntype TLSConfig struct {\n\tSkipVerify bool\n\tCA         string\n\tCert       string\n\tKey        string\n\tServerName string\n}\n",
      "kind": 2,
      "metadata": {
        "id": 1,
        "type": "originalCode",
        "lineNumberBase": 46
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "2",
      "value": "\n// Client represents a client instance\ntype Client struct {\n\t*cio.Logger\n\tconfig    *Config\n\tcomputed  settings.Config\n\tsshConfig *ssh.ClientConfig\n\ttlsConfig *tls.Config\n\tproxyURL  *url.URL\n\tserver    string\n\tconnCount cnet.ConnCount\n\tstop      func()\n\teg        *errgroup.Group\n\ttunnel    *tunnel.Tunnel\n}\n",
      "kind": 2,
      "metadata": {
        "id": 2,
        "type": "originalCode",
        "lineNumberBase": 55
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "3",
      "value": "\n// NewClient creates a new client instance\nfunc NewClient(c *Config) (*Client, error) {\n\t//apply default scheme\n\tif !strings.HasPrefix(c.Server, \"http\") {\n\t\tc.Server = \"http://\" + c.Server\n\t}\n\tif c.MaxRetryInterval < time.Second {\n\t\tc.MaxRetryInterval = 5 * time.Minute\n\t}\n\tu, err := url.Parse(c.Server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t//swap to websockets scheme\n\tu.Scheme = strings.Replace(u.Scheme, \"http\", \"ws\", 1)\n\t//apply default port\n\tif !regexp.MustCompile(`:\\d+$`).MatchString(u.Host) {\n\t\tif u.Scheme == \"wss\" {\n\t\t\tu.Host = u.Host + \":443\"\n\t\t} else {\n\t\t\tu.Host = u.Host + \":80\"\n\t\t}\n\t}\n\thasReverse := false\n\thasSocks := false\n\thasStdio := false\n\tclient := &Client{\n\t\tLogger: cio.NewLogger(\"client\"),\n\t\tconfig: c,\n\t\tcomputed: settings.Config{\n\t\t\tVersion: chshare.BuildVersion,\n\t\t},\n\t\tserver:    u.String(),\n\t\ttlsConfig: nil,\n\t}\n\t//set default log level\n\tclient.Logger.Info = true\n\t//configure tls\n\tif u.Scheme == \"wss\" {\n\t\ttc := &tls.Config{}\n\t\tif c.TLS.ServerName != \"\" {\n\t\t\ttc.ServerName = c.TLS.ServerName\n\t\t}\n\t\t//certificate verification config\n\t\tif c.TLS.SkipVerify {\n\t\t\tclient.Infof(\"TLS verification disabled\")\n\t\t\ttc.InsecureSkipVerify = true\n\t\t} else if c.TLS.CA != \"\" {\n\t\t\trootCAs := x509.NewCertPool()\n\t\t\tif b, err := ioutil.ReadFile(c.TLS.CA); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"Failed to load file: %s\", c.TLS.CA)\n\t\t\t} else if ok := rootCAs.AppendCertsFromPEM(b); !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"Failed to decode PEM: %s\", c.TLS.CA)\n\t\t\t} else {\n\t\t\t\tclient.Infof(\"TLS verification using CA %s\", c.TLS.CA)\n\t\t\t\ttc.RootCAs = rootCAs\n\t\t\t}\n\t\t}\n\t\t//provide client cert and key pair for mtls\n\t\tif c.TLS.Cert != \"\" && c.TLS.Key != \"\" {\n\t\t\tc, err := tls.LoadX509KeyPair(c.TLS.Cert, c.TLS.Key)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"Error loading client cert and key pair: %v\", err)\n\t\t\t}\n\t\t\ttc.Certificates = []tls.Certificate{c}\n\t\t} else if c.TLS.Cert != \"\" || c.TLS.Key != \"\" {\n\t\t\treturn nil, fmt.Errorf(\"Please specify client BOTH cert and key\")\n\t\t}\n\t\tclient.tlsConfig = tc\n\t}\n\t//validate remotes\n\tfor _, s := range c.Remotes {\n\t\tr, err := settings.DecodeRemote(s)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Failed to decode remote '%s': %s\", s, err)\n\t\t}\n\t\tif r.Socks {\n\t\t\thasSocks = true\n\t\t}\n\t\tif r.Reverse {\n\t\t\thasReverse = true\n\t\t}\n\t\tif r.Stdio {\n\t\t\tif hasStdio {\n\t\t\t\treturn nil, errors.New(\"Only one stdio is allowed\")\n\t\t\t}\n\t\t\thasStdio = true\n\t\t}\n\t\t//confirm non-reverse tunnel is available\n\t\tif !r.Reverse && !r.Stdio && !r.CanListen() {\n\t\t\treturn nil, fmt.Errorf(\"Client cannot listen on %s\", r.String())\n\t\t}\n\t\tclient.computed.Remotes = append(client.computed.Remotes, r)\n\t}\n\t//outbound proxy\n\tif p := c.Proxy; p != \"\" {\n\t\tclient.proxyURL, err = url.Parse(p)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Invalid proxy URL (%s)\", err)\n\t\t}\n\t}\n\t//ssh auth and config\n\tuser, pass := settings.ParseAuth(c.Auth)\n\tclient.sshConfig = &ssh.ClientConfig{\n\t\tUser:            user,\n\t\tAuth:            []ssh.AuthMethod{ssh.Password(pass)},\n\t\tClientVersion:   \"SSH-\" + chshare.ProtocolVersion + \"-client\",\n\t\tHostKeyCallback: client.verifyServer,\n\t\tTimeout:         settings.EnvDuration(\"SSH_TIMEOUT\", 30*time.Second),\n\t}\n\t//prepare client tunnel\n\tclient.tunnel = tunnel.New(tunnel.Config{\n\t\tLogger:    client.Logger,\n\t\tInbound:   true, //client always accepts inbound\n\t\tOutbound:  hasReverse,\n\t\tSocks:     hasReverse && hasSocks,\n\t\tKeepAlive: client.config.KeepAlive,\n\t})\n\treturn client, nil\n}\n",
      "kind": 2,
      "metadata": {
        "id": 3,
        "type": "originalCode",
        "lineNumberBase": 70
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "4",
      "value": "\n// Run starts client and blocks while connected\nfunc (c *Client) Run() error {\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\tif err := c.Start(ctx); err != nil {\n\t\treturn err\n\t}\n\treturn c.Wait()\n}\n",
      "kind": 2,
      "metadata": {
        "id": 4,
        "type": "originalCode",
        "lineNumberBase": 191
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "5",
      "value": "\nfunc (c *Client) verifyServer(hostname string, remote net.Addr, key ssh.PublicKey) error {\n\texpect := c.config.Fingerprint\n\tif expect == \"\" {\n\t\treturn nil\n\t}\n\tgot := ccrypto.FingerprintKey(key)\n\t_, err := base64.StdEncoding.DecodeString(expect)\n\tif _, ok := err.(base64.CorruptInputError); ok {\n\t\tc.Logger.Infof(\"Specified deprecated MD5 fingerprint (%s), please update to the new SHA256 fingerprint: %s\", expect, got)\n\t\treturn c.verifyLegacyFingerprint(key)\n\t} else if err != nil {\n\t\treturn fmt.Errorf(\"Error decoding fingerprint: %w\", err)\n\t}\n\tif got != expect {\n\t\treturn fmt.Errorf(\"Invalid fingerprint (%s)\", got)\n\t}\n\t//overwrite with complete fingerprint\n\tc.Infof(\"Fingerprint %s\", got)\n\treturn nil\n}\n",
      "kind": 2,
      "metadata": {
        "id": 5,
        "type": "originalCode",
        "lineNumberBase": 201
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "6",
      "value": "\n// verifyLegacyFingerprint calculates and compares legacy MD5 fingerprints\nfunc (c *Client) verifyLegacyFingerprint(key ssh.PublicKey) error {\n\tbytes := md5.Sum(key.Marshal())\n\tstrbytes := make([]string, len(bytes))\n\tfor i, b := range bytes {\n\t\tstrbytes[i] = fmt.Sprintf(\"%02x\", b)\n\t}\n\tgot := strings.Join(strbytes, \":\")\n\texpect := c.config.Fingerprint\n\tif !strings.HasPrefix(got, expect) {\n\t\treturn fmt.Errorf(\"Invalid fingerprint (%s)\", got)\n\t}\n\treturn nil\n}\n",
      "kind": 2,
      "metadata": {
        "id": 6,
        "type": "originalCode",
        "lineNumberBase": 222
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "7",
      "value": "\n// Start client and does not block\nfunc (c *Client) Start(ctx context.Context) error {\n\tctx, cancel := context.WithCancel(ctx)\n\tc.stop = cancel\n\teg, ctx := errgroup.WithContext(ctx)\n\tc.eg = eg\n\tvia := \"\"\n\tif c.proxyURL != nil {\n\t\tvia = \" via \" + c.proxyURL.String()\n\t}\n\tc.Infof(\"Connecting to %s%s\\n\", c.server, via)\n\t//connect to chisel server\n\teg.Go(func() error {\n\t\treturn c.connectionLoop(ctx)\n\t})\n\t//listen sockets\n\teg.Go(func() error {\n\t\tclientInbound := c.computed.Remotes.Reversed(false)\n\t\tif len(clientInbound) == 0 {\n\t\t\treturn nil\n\t\t}\n\t\treturn c.tunnel.BindRemotes(ctx, clientInbound)\n\t})\n\treturn nil\n}\n",
      "kind": 2,
      "metadata": {
        "id": 7,
        "type": "originalCode",
        "lineNumberBase": 237
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "8",
      "value": "\nfunc (c *Client) setProxy(u *url.URL, d *websocket.Dialer) error {\n\t// CONNECT proxy\n\tif !strings.HasPrefix(u.Scheme, \"socks\") {\n\t\td.Proxy = func(*http.Request) (*url.URL, error) {\n\t\t\treturn u, nil\n\t\t}\n\t\treturn nil\n\t}\n\t// SOCKS5 proxy\n\tif u.Scheme != \"socks\" && u.Scheme != \"socks5h\" {\n\t\treturn fmt.Errorf(\n\t\t\t\"unsupported socks proxy type: %s:// (only socks5h:// or socks:// is supported)\",\n\t\t\tu.Scheme,\n\t\t)\n\t}\n\tvar auth *proxy.Auth\n\tif u.User != nil {\n\t\tpass, _ := u.User.Password()\n\t\tauth = &proxy.Auth{\n\t\t\tUser:     u.User.Username(),\n\t\t\tPassword: pass,\n\t\t}\n\t}\n\tsocksDialer, err := proxy.SOCKS5(\"tcp\", u.Host, auth, proxy.Direct)\n\tif err != nil {\n\t\treturn err\n\t}\n\td.NetDial = socksDialer.Dial\n\treturn nil\n}\n",
      "kind": 2,
      "metadata": {
        "id": 8,
        "type": "originalCode",
        "lineNumberBase": 263
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "9",
      "value": "\n// Wait blocks while the client is running.\nfunc (c *Client) Wait() error {\n\treturn c.eg.Wait()\n}\n",
      "kind": 2,
      "metadata": {
        "id": 9,
        "type": "originalCode",
        "lineNumberBase": 294
      }
    },
    {
      "outputs": [],
      "languageId": "go",
      "id": "10",
      "value": "\n// Close manually stops the client\nfunc (c *Client) Close() error {\n\tif c.stop != nil {\n\t\tc.stop()\n\t}\n\treturn nil\n}\n",
      "kind": 2,
      "metadata": {
        "id": 10,
        "type": "originalCode",
        "lineNumberBase": 299
      }
    }
  ],
  "metadata": {
    "defaultDir": ".boost",
    "sourceFile": "./client/client.go"
  }
}